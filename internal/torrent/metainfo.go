package torrent

import (
	"crypto/sha1"
	"fmt"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/MlkMahmud/hail/internal/bencode"
	"github.com/MlkMahmud/hail/internal/utils"
)

type parsedFilesResult struct {
	files       []file
	totalLength int
}

func mapFilesToPieces(files []file, totalLength int, piecesHashes string, pieceLength int) (*torrentInfo, error) {
	cumulativePiecesLength := 0
	piecesHashesLen := len(piecesHashes)

	if piecesHashesLen%sha1.Size != 0 {
		return nil, fmt.Errorf("the 'pieces' string length must be a multiple of %d", sha1.Size)
	}

	numOfPieces := piecesHashesLen / sha1.Size
	pieces := make([]piece, numOfPieces)

	filesArr := make([]file, len(files))
	fileOffset := 0
	pieceIndex := 0

	for fileIndex := range files {
		file := files[fileIndex]

		pieceStartIndex := pieceIndex
		pieceEndIndex := pieceStartIndex + (file.length+fileOffset-1)/pieceLength

		file.startOffsetInFirstPiece = fileOffset
		file.pieceEndIndex = pieceEndIndex
		file.pieceStartIndex = pieceStartIndex

		for index := pieceStartIndex; index <= pieceEndIndex; index++ {
			if reflect.ValueOf(pieces[index]).IsZero() {
				hash := [sha1.Size]byte{}
				isLastPiece := index == (numOfPieces - 1)
				piecesStrIndex := index * sha1.Size

				copy(hash[:], []byte(piecesHashes[piecesStrIndex:piecesStrIndex+sha1.Size]))
				pieces[index].index = index
				pieces[index].fileIndexes = []int{}
				pieces[index].hash = hash

				/*
					All pieces have the same fixed length, except the last piece which may be truncated.
					The truncated length of the last piece can be generated by subtracting the sum of all other pieces from the total length of the file.
				*/
				if isLastPiece {
					pieces[index].length = totalLength - (pieceLength * (numOfPieces - 1))
				} else {
					pieces[index].length = pieceLength
				}

				cumulativePiecesLength += pieces[index].length
			}

			pieces[index].fileIndexes = append(pieces[index].fileIndexes, fileIndex)
		}

		// If the file fits entirely within a single piece
		if fileOffset+file.length <= pieceLength {
			file.endOffsetInLastPiece = file.startOffsetInFirstPiece + file.length
			// If the file spans multiple pieces and does not end on the border of its last piece
		} else if endOffset := (file.length + fileOffset) % pieceLength; endOffset != 0 {
			file.endOffsetInLastPiece = endOffset
			// If the file ends exactly at the boundary of its last piece
		} else {
			file.endOffsetInLastPiece = pieces[file.pieceEndIndex].length
		}

		fileOffset = (file.length + fileOffset) % pieceLength
		filesArr[fileIndex] = file

		// Only increment pieceIndex if the file ends exactly at the boundary of the last piece
		if fileOffset > 0 {
			pieceIndex = pieceEndIndex
		} else {
			pieceIndex = pieceEndIndex + 1
		}
	}

	if totalLength != cumulativePiecesLength {
		return nil, fmt.Errorf("total length of all files (%d) does not match the total length of all pieces (%d)", totalLength, cumulativePiecesLength)
	}

	return &torrentInfo{
		files:       filesArr,
		length:      totalLength,
		pieceLength: pieceLength,
		pieces:      pieces,
	}, nil
}

func parseAnnounceList(list any) (*utils.Set, error) {
	trackers := utils.NewSet()

	announceList, ok := list.([]any)

	if !ok {
		return nil, fmt.Errorf("\"announce-list\" property should be a list, but received '%T'", announceList)
	}

	for listIndex, tier := range announceList {
		tierList, ok := tier.([]any)

		if !ok {
			return nil, fmt.Errorf("announce list contains an invalid entry at index %d", listIndex)
		}

		for tierIndex, url := range tierList {
			urlStr, ok := url.(string)

			if !ok {
				return nil, fmt.Errorf("announce list entry at index %d contains an invalid entry at index %d", listIndex, tierIndex)
			}

			if strings.HasPrefix(urlStr, "http://") || strings.HasPrefix(urlStr, "https://") || strings.HasPrefix(urlStr, "udp://") {
				trackers.Add(urlStr)
			}
		}
	}

	return trackers, nil
}

func parseFileEntry(fileEntry any) (file, error) {
	entry, ok := fileEntry.(map[string]any)

	if !ok {
		return file{}, fmt.Errorf("file entry is not a valid dictionary, received '%T'", fileEntry)
	}

	fileLength, ok := entry["length"].(int)

	if !ok {
		return file{}, fmt.Errorf("file entry is missing or has an invalid 'length' property, expected an integer but received '%T'", entry["length"])
	}

	paths, ok := entry["path"].([]any)

	if !ok || len(paths) < 1 {
		return file{}, fmt.Errorf("file entry has an invalid or empty 'path' property, expected a non-empty list but received '%T'", entry["path"])
	}

	pathList := make([]string, len(paths))

	for j, pathEntry := range paths {
		pathStr, ok := pathEntry.(string)

		if !ok {
			return file{}, fmt.Errorf("file entry 'path' property contains an invalid component at index %d, expected a string but received '%T'", j, pathEntry)
		}
		pathList[j] = pathStr
	}

	return file{
		length: fileLength,
		name:   filepath.Join(pathList...),
	}, nil
}

func parseFilesList(filesList []any) (parsedFilesResult, error) {
	files := make([]file, len(filesList))
	totalLength := 0

	for i, fileEntry := range filesList {
		entry, err := parseFileEntry(fileEntry)

		if err != nil {
			return parsedFilesResult{}, fmt.Errorf("failed to parse file entry at index %d: %w", i, err)
		}

		files[i] = entry
		totalLength += entry.length
	}

	return parsedFilesResult{
		files:       files,
		totalLength: totalLength,
	}, nil
}

func parseInfoDict(infoDict map[string]any) (*torrentInfo, error) {
	if err := validateRequiredKeys(infoDict, map[string]any{"name": "", "piece length": 0, "pieces": ""}); err != nil {
		return nil, err
	}

	name := infoDict["name"].(string)
	pieceLength := infoDict["piece length"].(int)
	piecesHashes := infoDict["pieces"].(string)

	switch files := infoDict["files"].(type) {
	case []any:
		results, err := parseFilesList(files)
		if err != nil {
			return nil, err
		}
		return mapFilesToPieces(results.files, results.totalLength, piecesHashes, pieceLength)
	case nil:
		break
	default:
		return nil, fmt.Errorf("'files' property of metainfo info dictionary must be a list or nil, got %T", files)
	}

	switch length := infoDict["length"].(type) {
	case int:
		return mapFilesToPieces(
			[]file{{length: length, name: name}},
			length,
			piecesHashes,
			pieceLength,
		)
	default:
		return nil, fmt.Errorf("'length' property of metainfo info dictionary must be an integer, got %T", length)
	}
}

func validateRequiredKeys(m map[string]any, required map[string]any) error {
	for key, val := range required {
		if _, exists := m[key]; !exists {
			return fmt.Errorf("missing required property '%s'", key)
		}
		if reflect.TypeOf(m[key]) != reflect.TypeOf(val) {
			return fmt.Errorf("property '%s' has wrong type", key)
		}
	}
	return nil
}

func newTorrentFromMetainfoFile(data []byte, opts NewTorrentOpts) (*Torrent, error) {
	var torrent Torrent

	decodedValue, _, err := bencode.DecodeValue(data)

	if err != nil {
		return nil, fmt.Errorf("failed to decode metainfo file: %w", err)
	}

	metainfo, ok := decodedValue.(map[string]any)

	if !ok {
		return nil, fmt.Errorf("expected metainfo to be a bencoded dictionary, but received '%T'", metainfo)
	}

	if err := validateRequiredKeys(metainfo, map[string]any{"announce": "", "info": make(map[string]any)}); err != nil {
		return nil, err
	}

	var announceListErr error
	trackers := utils.NewSet()

	if announceList, ok := metainfo["announce-list"]; ok {
		trackers, announceListErr = parseAnnounceList(announceList)
	} else {
		trackers.Add(metainfo["announce"].(string))
	}

	if announceListErr != nil {
		return nil, fmt.Errorf("failed to parse announce list: %w", announceListErr)
	}

	torrentInfo, err := parseInfoDict(metainfo["info"].(map[string]any))

	if err != nil {
		return nil, fmt.Errorf("failed to parse metainfo 'info' dictionary %w", err)
	}

	bencodedValue, err := bencode.EncodeValue(metainfo["info"])

	if err != nil {
		return nil, fmt.Errorf("failed to encode metainfo 'info' dictionary")
	}

	torrent.info = torrentInfo
	torrent.infoHash = sha1.Sum([]byte(bencodedValue))
	torrent.logger = opts.Logger
	torrent.peerId = opts.PeerId
	torrent.outputDir = opts.OutputDir

	torrent.metadataDownloadCompletedCh = make(chan struct{}, 1)
	torrent.piecesDownloadCompleteCh = make(chan struct{}, 1)

	torrent.incomingPeersCh = make(chan []*peer, 1)
	torrent.maxPeerConnections = 10
	torrent.metadataPeersCh = make(chan *peer, 5)

	torrent.activePeerIds = *utils.NewSet()
	torrent.peers = make(map[string]*peer)

	torrent.downloadedPieceCh = make(chan downloadedPiece, 10)
	torrent.failedPiecesCh = make(chan piece, 10)
	torrent.queuedPiecesCh = make(chan piece, 10)

	torrent.trackers = *trackers
	torrent.statusCh = make(chan torrentStatus, 1)

	return &torrent, nil
}

package torrent

import (
	"bytes"
	"crypto/sha1"
	"fmt"
	"math"
	"os"
	"path/filepath"
)

type Block struct {
	Begin     int
	Data      []byte
	Length    int
	PiceIndex int
}

type DownloadedPiece struct {
	Data  []byte
	Err   error
	Piece Piece
}

type Piece struct {
	Index  int
	Hash   [sha1.Size]byte
	Length int
	Offset int
}

type piecesParserConfig struct {
	fileLength         int
	initialPieceOffset int
	pieceLength        int
	piecesHashes       string
}

type piecesParserResult struct {
	nextFileStartOffset int
	nextPieceStartIndex int
	pieces              []Piece
}

const (
	BlockSize = 16384
)

func parsePiecesHashes(config piecesParserConfig) (piecesParserResult, error) {
	result := piecesParserResult{
		nextFileStartOffset: 0,
		nextPieceStartIndex: 0,
		pieces:              nil,
	}

	availablePiecesLen := len(config.piecesHashes)
	numOfPieces := int(math.Ceil(float64(config.fileLength) / float64(config.pieceLength)))
	piecesArr := make([]Piece, numOfPieces)
	piecesIndex := 0

	if availablePiecesLen%sha1.Size != 0 {
		return result, fmt.Errorf("pieces length must be a multiple of %d", sha1.Size)
	}

	if numOfAvailablePieces := availablePiecesLen / sha1.Size; numOfAvailablePieces < numOfPieces {
		return result, fmt.Errorf("expected pieces hash to contain at least %d pieces, but got %d", numOfPieces, numOfAvailablePieces)
	}

	for i := range numOfPieces {
		pieceHash := []byte(config.piecesHashes[piecesIndex : sha1.Size+piecesIndex])

		if len(pieceHash) != sha1.Size {
			return result, fmt.Errorf("piece %d has an invalid hash", i)
		}

		piece := Piece{Index: i, Hash: [sha1.Size]byte(pieceHash)}

		isFirstPiece := i == 0
		isLastPiece := i == (numOfPieces - 1)

		if isFirstPiece {
			piece.Offset = config.initialPieceOffset
		}

		/*
			All pieces have the same fixed length, except the last piece which may be truncated.
			The truncated length of the last piece can be generated by subtracting the sum of all other pieces from the total length of the file.
		*/
		if isLastPiece {
			piece.Length = config.fileLength - (config.pieceLength * (numOfPieces - 1))
		} else {
			piece.Length = config.pieceLength
		}

		// If it's not a truncated piece advance the pieces hash index and set the start offset for the next file to 0.
		if piece.Length == config.pieceLength {
			piecesIndex += sha1.Size
			result.nextFileStartOffset = 0
		} else {
			/*
				In multi-file torrents a single piece can contain data for two files.
				If the last piece of a file is truncated, then that piece includes data
				for the next file too. We need to calculate the offset to know exactly at which
				byte the data for the next file begins.
			*/
			result.nextFileStartOffset = piece.Length
		}

		piecesArr[i] = piece
	}

	result.nextPieceStartIndex = piecesIndex
	result.pieces = piecesArr

	return result, nil

}

func parseTorrentPieces(infoDict map[string]any) ([]Piece, error) {
	pieceHashes, ok := infoDict["pieces"].(string)

	if !ok {
		return nil, fmt.Errorf("expected the 'pieces' property of the info dict to be a string, but got %T", pieceHashes)
	}

	pieceHashesLen := len(pieceHashes)

	if pieceHashesLen == 0 {
		return nil, fmt.Errorf("the 'pieces' property cannot be an empty string")
	}

	if pieceHashesLen%sha1.Size != 0 {
		return nil, fmt.Errorf("pieces length must be a multiple of %d", sha1.Size)
	}

	pieceLen, ok := infoDict["piece length"].(int)

	if !ok {
		return nil, fmt.Errorf("expected the 'piece length' property of the info dict to be an integer, but got %T", pieceLen)
	}

	fileLen, ok := infoDict["length"].(int)

	if !ok {
		return nil, fmt.Errorf("expected the 'length' property of the info dict to be an integer, but got %T", fileLen)
	}

	numOfPieces := pieceHashesLen / sha1.Size
	piecesArr := make([]Piece, numOfPieces)

	for i, j := 0, 0; i < pieceHashesLen; i += sha1.Size {
		pieceHash := []byte(pieceHashes[i : sha1.Size+i])

		if len(pieceHash) != sha1.Size {
			return nil, fmt.Errorf("piece %d has an invalid hash", j)
		}

		piece := Piece{Index: j, Hash: [sha1.Size]byte(pieceHash)}

		// All pieces have the same fixed length, except the last piece which may be truncated
		// The truncated length of the last piece can be generated by subtracting the sum of all other pieces from the total length of the file.
		if j == numOfPieces-1 {
			piece.Length = fileLen - (pieceLen * (numOfPieces - 1))
		} else {
			piece.Length = pieceLen
		}

		piecesArr[j] = piece
		j++
	}

	return piecesArr, nil
}

func (p *Piece) assembleBlocks(blocks []Block) []byte {
	buffer := make([]byte, p.Length)

	for _, block := range blocks {
		copy(buffer[block.Begin:], block.Data)
	}

	return buffer
}

func (d *DownloadedPiece) CheckHashIntegrity() error {
	downloadedPieceHash := sha1.Sum(d.Data)

	if bytes.Equal(downloadedPieceHash[:], d.Piece.Hash[:]) {
		return nil
	}

	return fmt.Errorf("hash '%x' for downloaded piece at index '%d' does not match expected '%x'", downloadedPieceHash, d.Piece.Index, d.Piece.Hash)
}

func (d *DownloadedPiece) WriteToDisk(dir string) error {
	path := filepath.Join(dir, fmt.Sprintf("%020d.piece", d.Piece.Index))

	if err := os.WriteFile(path, d.Data, 0666); err != nil {
		return fmt.Errorf("failed to write piece '%d' to disk: %w", d.Piece.Index, err)
	}

	return nil
}

func (p *Piece) getBlocks() []Block {
	blocks := []Block{}

	numOfFullSizedBlocks := int(p.Length / BlockSize)

	for i := 0; i < numOfFullSizedBlocks; i++ {
		blocks = append(blocks, Block{Begin: i * BlockSize, Length: BlockSize, PiceIndex: p.Index})
	}

	if lastBlockSize := p.Length % BlockSize; lastBlockSize != 0 {
		lastBlockIndex := numOfFullSizedBlocks * BlockSize
		blocks = append(blocks, Block{Begin: lastBlockIndex, Length: lastBlockSize, PiceIndex: p.Index})
	}

	return blocks
}

package torrent

import (
	"crypto/sha1"
	"fmt"
	"maps"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/MlkMahmud/hail/bencode"
	"github.com/MlkMahmud/hail/utils"
)

func parseAnnounceList(list any) (*utils.Set, error) {
	trackers := utils.NewSet()

	announceList, ok := list.([]any)

	if !ok {
		return nil, fmt.Errorf("\"announce-list\" property should be a list, but received '%T'", announceList)
	}

	for listIndex, tier := range announceList {
		tierList, ok := tier.([]any)

		if !ok {
			return nil, fmt.Errorf("announce list contains an invalid entry at index %d", listIndex)
		}

		for tierIndex, url := range tierList {
			urlStr, ok := url.(string)

			if !ok {
				return nil, fmt.Errorf("announce list entry at index %d contains an invalid entry at index %d", listIndex, tierIndex)
			}

			if strings.HasPrefix(urlStr, "http://") || strings.HasPrefix(urlStr, "https://") || strings.HasPrefix(urlStr, "udp://") {
				trackers.Add(urlStr)
			}
		}
	}

	return trackers, nil
}

func parseFileEntry(fileEntry any) (file, error) {
	entry, ok := fileEntry.(map[string]any)

	if !ok {
		return file{}, fmt.Errorf("file entry is not a valid dictionary, received '%T'", fileEntry)
	}

	fileLength, ok := entry["length"].(int)

	if !ok {
		return file{}, fmt.Errorf("file entry is missing or has an invalid 'length' property, expected an integer but received '%T'", entry["length"])
	}

	paths, ok := entry["path"].([]any)

	if !ok || len(paths) < 1 {
		return file{}, fmt.Errorf("file entry has an invalid or empty 'path' property, expected a non-empty list but received '%T'", entry["path"])
	}

	pathList := make([]string, len(paths))

	for j, pathEntry := range paths {
		pathStr, ok := pathEntry.(string)

		if !ok {
			return file{}, fmt.Errorf("file entry 'path' property contains an invalid component at index %d, expected a string but received '%T'", j, pathEntry)
		}
		pathList[j] = pathStr
	}

	return file{
		length: fileLength,
		name:   filepath.Join(pathList...),
	}, nil
}

func parseFilesList(infoDict map[string]any) (*torrentInfo, error) {
	filesList, ok := infoDict["files"].([]any)

	if !ok {
		return nil, fmt.Errorf("expected 'files' property to be a list, but received '%T'", infoDict["files"])
	}

	numOfFiles := len(filesList)
	files := make([]file, numOfFiles)

	cummulativeFilesLength := 0
	cummulativePiecesLength := 0

	pieceLength, ok := infoDict["piece length"].(int)

	if !ok {
		return nil, fmt.Errorf("expected 'piece length' to be an integer, but received '%T'", infoDict["piece length"])
	}

	piecesStr, ok := infoDict["pieces"].(string)

	if !ok {
		return nil, fmt.Errorf("expected 'pieces' to be a string, but received '%T'", infoDict["pieces"])
	}

	if len(piecesStr)%sha1.Size != 0 {
		return nil, fmt.Errorf("'pieces' string length is not a multiple of %d", sha1.Size)
	}

	numOfPieces := len(piecesStr) / sha1.Size
	pieces := make([]piece, numOfPieces)

	fileOffset := 0
	pieceIndex := 0

	for fileIndex, fileEntry := range filesList {
		entry, err := parseFileEntry(fileEntry)

		if err != nil {
			return nil, fmt.Errorf("failed to parse file entry at index '%d': %w", fileIndex, err)
		}

		pieceStartIndex := pieceIndex
		pieceEndIndex := pieceStartIndex + (entry.length+fileOffset-1)/pieceLength

		entry.startOffsetInFirstPiece = fileOffset
		entry.pieceEndIndex = pieceEndIndex
		entry.pieceStartIndex = pieceStartIndex

		cummulativeFilesLength += entry.length

		for index := pieceStartIndex; index <= pieceEndIndex; index++ {
			if reflect.ValueOf(pieces[index]).IsZero() {
				hash := [sha1.Size]byte{}
				isLastPiece := index == (numOfPieces - 1)
				piecesStrIndex := index * sha1.Size

				copy(hash[:], []byte(piecesStr[piecesStrIndex:piecesStrIndex+sha1.Size]))
				pieces[index].index = index
				pieces[index].fileIndexes = []int{}
				pieces[index].hash = hash

				/*
					All pieces have the same fixed length, except the last piece which may be truncated.
					The truncated length of the last piece can be generated by subtracting the sum of all other pieces from the total length of the file.
				*/
				if isLastPiece {
					pieces[index].length = cummulativeFilesLength - (pieceLength * (numOfPieces - 1))
				} else {
					pieces[index].length = pieceLength
				}

				cummulativePiecesLength += pieces[index].length
			}

			pieces[index].fileIndexes = append(pieces[index].fileIndexes, fileIndex)
		}

		// If the file fits entirely within a single piece
		if fileOffset+entry.length <= pieceLength {
			entry.endOffsetInLastPiece = entry.length
			// If the file spans multiple pieces and does not end on the border of its last piece
		} else if endOffset := (entry.length + fileOffset) % pieceLength; endOffset != 0 {
			entry.endOffsetInLastPiece = endOffset
			// If the file ends exactly at the boundary of its last piece
		} else {
			entry.endOffsetInLastPiece = pieces[entry.pieceEndIndex].length
		}

		fileOffset = (entry.length + fileOffset) % pieceLength
		files[fileIndex] = entry

		// Only increment pieceIndex if the file ends exactly at the boundary of the last piece
		if fileOffset > 0 {
			pieceIndex = pieceEndIndex
		} else {
			pieceIndex = pieceEndIndex + 1
		}
	}

	if cummulativeFilesLength != cummulativePiecesLength {
		return nil, fmt.Errorf("total length of all files (%d) does not match the total length of all pieces (%d)", cummulativeFilesLength, cummulativePiecesLength)
	}

	return &torrentInfo{
		files:  files,
		length: cummulativeFilesLength,
		pieces: pieces,
	}, nil
}

func parseInfoDict(infoDict map[string]any) (*torrentInfo, error) {
	for key, value := range map[string]any{"name": "", "piece length": 0, "pieces": ""} {
		if _, exists := infoDict[key]; !exists {
			return nil, fmt.Errorf("metainfo 'info' dictionary is missing required property '%s'", key)
		}

		expectedType := reflect.TypeOf(value)
		receivedType := reflect.TypeOf(infoDict[key])

		if receivedType != expectedType {
			return nil, fmt.Errorf("expected the '%s' property to be of type '%v', but received '%v'", key, expectedType, receivedType)
		}
	}

	if _, ok := infoDict["files"]; ok {
		return parseFilesList(infoDict)
	}

	if _, ok := infoDict["length"]; !ok {
		return nil, fmt.Errorf("metainfo 'info' dictionary must contain a 'files' or 'length' property")
	}

	fileLength, ok := infoDict["length"].(int)

	if !ok {
		return nil, fmt.Errorf("'length' property of metainfo info dictionary must be an integer not %T", fileLength)
	}

	infoDictWithFilesList := maps.Clone(infoDict)
	infoDictWithFilesList["files"] = []any{
		map[string]any{
			"length": fileLength,
			"path":   []any{infoDict["name"].(string)},
		},
	}
	return parseFilesList(infoDictWithFilesList)
}

func newTorrentFromMetainfoFile(data []byte, opts NewTorrentOpts) (*Torrent, error) {
	var torrent Torrent

	decodedValue, _, err := bencode.DecodeValue(data)

	if err != nil {
		return nil, fmt.Errorf("failed to decode metainfo file: %w", err)
	}

	metainfo, ok := decodedValue.(map[string]any)

	if !ok {
		return nil, fmt.Errorf("expected metainfo to be a bencoded dictionary, but received '%T'", metainfo)
	}

	for key, value := range map[string]any{"announce": "string", "info": make(map[string]any)} {
		if _, exists := metainfo[key]; !exists {
			return nil, fmt.Errorf("metainfo dictionary is missing required property '%s'", key)
		}

		expectedType := reflect.TypeOf(value)
		receivedType := reflect.TypeOf(metainfo[key])

		if receivedType != expectedType {
			return nil, fmt.Errorf("expected the '%s' property to be of type '%v', but received '%v'", key, expectedType, receivedType)
		}
	}

	var announceListErr error
	trackers := utils.NewSet()

	if announceList, ok := metainfo["announce-list"]; ok {
		trackers, announceListErr = parseAnnounceList(announceList)
	} else {
		trackers.Add(metainfo["announce"].(string))
	}

	if announceListErr != nil {
		return nil, fmt.Errorf("failed to parse announce list: %w", announceListErr)
	}

	torrentInfo, err := parseInfoDict(metainfo["info"].(map[string]any))

	if err != nil {
		return nil, fmt.Errorf("failed to parse metainfo 'info' dictionary %w", err)
	}

	bencodedValue, err := bencode.EncodeValue(metainfo["info"])

	if err != nil {
		return nil, fmt.Errorf("failed to encode metainfo 'info' dictionary")
	}

	torrent.info = torrentInfo
	torrent.infoHash = sha1.Sum([]byte(bencodedValue))
	torrent.peerId = opts.PeerId
	torrent.outputDir = opts.OutputDir

	torrent.metadataDownloadCompletedCh = make(chan struct{}, 1)
	torrent.piecesDownloadCompleteCh = make(chan struct{}, 1)

	torrent.incomingPeersCh = make(chan []peer, 1)
	torrent.maxPeerConnections = 10
	torrent.metadataPeersCh = make(chan peerConnection, 10)
	torrent.peerConnectionPool = newPeerConnectionPool()
	torrent.peers = make(map[string]peer)
	torrent.failingPeers = make(map[string]peer)

	torrent.downloadedPieceCh = make(chan downloadedPiece, 10)
	torrent.failedPiecesCh = make(chan piece, 10)
	torrent.queuedPiecesCh = make(chan piece, 10)

	torrent.trackers = *trackers
	torrent.statusCh = make(chan torrentStatus, 1)

	return &torrent, nil
}

package torrent

import (
	"crypto/sha1"
	"fmt"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/MlkMahmud/hail/bencode"
	"github.com/MlkMahmud/hail/utils"
)

func parseAnnounceList(list any) (*utils.Set, error) {
	trackers := utils.NewSet()

	announceList, ok := list.([]any)

	if !ok {
		return nil, fmt.Errorf("\"announce-list\" property should be a list, but received '%T'", announceList)
	}

	for listIndex, tier := range announceList {
		tierList, ok := tier.([]any)

		if !ok {
			return nil, fmt.Errorf("announce list contains an invalid entry at index %d", listIndex)
		}

		for tierIndex, url := range tierList {
			urlStr, ok := url.(string)

			if !ok {
				return nil, fmt.Errorf("announce list entry at index %d contains an invalid entry at index %d", listIndex, tierIndex)
			}

			if strings.HasPrefix(urlStr, "http://") || strings.HasPrefix(urlStr, "https://") || strings.HasPrefix(urlStr, "udp://") {
				trackers.Add(urlStr)
			}
		}
	}

	return trackers, nil
}

func parseFilesList(infoDict map[string]any) (*torrentInfo, error) {
	filesList, ok := infoDict["files"].([]any)

	if !ok {
		return nil, fmt.Errorf("expected 'files' property to be a list, but received '%T'", infoDict["files"])
	}

	numOfFiles := len(filesList)
	files := make([]file, numOfFiles)

	cummulativeFilesLength := 0
	cummulativePiecesLength := 0

	pieceLength, ok := infoDict["piece length"].(int)

	if !ok {
		return nil, fmt.Errorf("expected 'piece length' to be an integer, but received '%T'", infoDict["piece length"])
	}

	piecesStr, ok := infoDict["pieces"].(string)

	if !ok {
		return nil, fmt.Errorf("expected 'pieces' to be a string, but received '%T'", infoDict["pieces"])
	}

	if len(piecesStr)%sha1.Size != 0 {
		return nil, fmt.Errorf("'pieces' string length is not a multiple of %d", sha1.Size)
	}

	numOfPieces := len(piecesStr) / sha1.Size
	pieces := make([]piece, numOfPieces)

	fileOffset := 0
	pieceIndex := 0

	for fileIndex, fileEntry := range filesList {
		entry, ok := fileEntry.(map[string]any)

		if !ok {
			return nil, fmt.Errorf("files list contains an invalid entry at index '%d'", fileIndex)
		}

		fileLength, ok := entry["length"].(int)

		if !ok {
			return nil, fmt.Errorf("files list entry at index '%d' contains an invalid 'length' property", fileIndex)
		}

		paths, ok := entry["path"].([]any)

		if !ok {
			return nil, fmt.Errorf("files list entry at index '%d' contains an invalid 'path' property", fileIndex)
		}

		pathList := make([]string, len(paths))

		for j, pathEntry := range paths {
			pathStr, ok := pathEntry.(string)

			if !ok {
				return nil, fmt.Errorf("files list entry at index '%d' contains an invalid 'path' property at index '%d'", fileIndex, j)
			}
			pathList[j] = pathStr
		}

		path := filepath.Join(pathList...)
		pieceStartIndex := pieceIndex
		pieceEndIndex := pieceStartIndex + (fileLength+fileOffset-1)/pieceLength

		files[fileIndex] = file{
			length:          fileLength,
			name:            path,
			offset:          fileOffset,
			pieceStartIndex: pieceStartIndex,
			pieceEndIndex:   pieceEndIndex,
		}

		fileOffset = (fileLength + fileOffset) % pieceLength
		cummulativeFilesLength += fileLength

		for index := pieceStartIndex; index <= pieceEndIndex; index++ {
			if reflect.ValueOf(pieces[index]).IsZero() {
				hash := [sha1.Size]byte{}
				isLastPiece := index == (numOfPieces - 1)

				copy(hash[:], []byte(piecesStr[pieceIndex:pieceIndex+sha1.Size]))
				pieces[index].index = index
				pieces[index].fileIndexes = []int{}
				pieces[index].hash = hash

				/*
					All pieces have the same fixed length, except the last piece which may be truncated.
					The truncated length of the last piece can be generated by subtracting the sum of all other pieces from the total length of the file.
				*/
				if isLastPiece {
					pieces[index].length = cummulativeFilesLength - (pieceLength * (numOfPieces - 1))
				} else {
					pieces[index].length = pieceLength
				}

				cummulativePiecesLength += pieces[index].length
			}

			pieces[index].fileIndexes = append(pieces[index].fileIndexes, fileIndex)
		}

		// Only increment pieceIndex if the file ends exactly at the boundary of the last piece
		if fileOffset > 0 {
			pieceIndex = pieceEndIndex
		} else {
			pieceIndex = pieceEndIndex + 1
		}
	}

	if cummulativeFilesLength != cummulativePiecesLength {
		return nil, fmt.Errorf("total length of all files (%d) does not match the total length of all pieces (%d)", cummulativeFilesLength, cummulativePiecesLength)
	}

	return &torrentInfo{
		files:  files,
		length: cummulativeFilesLength,
		pieces: pieces,
	}, nil
}

func parseInfoDict(infoDict map[string]any) (*torrentInfo, error) {
	for key, value := range map[string]any{"name": "", "piece length": 0, "pieces": ""} {
		if _, exists := infoDict[key]; !exists {
			return nil, fmt.Errorf("metainfo 'info' dictionary is missing required property '%s'", key)
		}

		expectedType := reflect.TypeOf(value)
		receivedType := reflect.TypeOf(infoDict[key])

		if receivedType != expectedType {
			return nil, fmt.Errorf("expected the '%s' property to be of type '%v', but received '%v'", key, expectedType, receivedType)
		}
	}

	if _, ok := infoDict["files"]; ok {
		info, err := parseFilesList(infoDict)

		return info, err
	}

	if _, ok := infoDict["length"]; !ok {
		return nil, fmt.Errorf("metainfo 'info' dictionary must contain a 'files' or 'length' property")
	}

	fileLength, ok := infoDict["length"].(int)

	if !ok {
		return nil, fmt.Errorf("'length' property of metainfo info dictionary must be an integer not %T", fileLength)
	}

	pieceLength := infoDict["piece length"].(int)
	pieceOffset := 0
	piecesHashes := infoDict["pieces"].(string)

	result, err := parsePiecesHashes(fileLength, pieceLength, pieceOffset, piecesHashes)

	if err != nil {
		return nil, fmt.Errorf("failed to parse pieces hashes: %w", err)
	}

	files := []file{{
		length:          fileLength,
		name:            infoDict["name"].(string),
		offset:          0,
		pieceEndIndex:   fileLength / pieceLength,
		pieceStartIndex: 0,
	}}

	return &torrentInfo{
		files:  files,
		length: fileLength,
		name:   infoDict["name"].(string),
		pieces: result.pieces,
	}, nil
}

func newTorrentFromMetainfoFile(data []byte, opts NewTorrentOpts) (*Torrent, error) {
	var torrent Torrent

	decodedValue, _, err := bencode.DecodeValue(data)

	if err != nil {
		return nil, fmt.Errorf("failed to decode metainfo file: %w", err)
	}

	metainfo, ok := decodedValue.(map[string]any)

	if !ok {
		return nil, fmt.Errorf("expected metainfo to be a bencoded dictionary, but received '%T'", metainfo)
	}

	for key, value := range map[string]any{"announce": "string", "info": make(map[string]any)} {
		if _, exists := metainfo[key]; !exists {
			return nil, fmt.Errorf("metainfo dictionary is missing required property '%s'", key)
		}

		expectedType := reflect.TypeOf(value)
		receivedType := reflect.TypeOf(metainfo[key])

		if receivedType != expectedType {
			return nil, fmt.Errorf("expected the '%s' property to be of type '%v', but received '%v'", key, expectedType, receivedType)
		}
	}

	var announceListErr error
	trackers := utils.NewSet()

	if announceList, ok := metainfo["announce-list"]; ok {
		trackers, announceListErr = parseAnnounceList(announceList)
	} else {
		trackers.Add(metainfo["announce"].(string))
	}

	if announceListErr != nil {
		return nil, fmt.Errorf("failed to parse announce list: %w", announceListErr)
	}

	torrentInfo, err := parseInfoDict(metainfo["info"].(map[string]any))

	if err != nil {
		return nil, fmt.Errorf("failed to parse metainfo 'info' dictionary %w", err)
	}

	bencodedValue, err := bencode.EncodeValue(metainfo["info"])

	if err != nil {
		return nil, fmt.Errorf("failed to encode metainfo 'info' dictionary")
	}

	torrent.info = torrentInfo
	torrent.infoHash = sha1.Sum([]byte(bencodedValue))
	torrent.peerId = opts.PeerId
	torrent.outputDir = opts.OutputDir

	torrent.metadataDownloadCompletedCh = make(chan struct{}, 1)
	torrent.piecesDownloadCompleteCh = make(chan struct{}, 1)

	torrent.incomingPeersCh = make(chan []peer, 1)
	torrent.maxPeerConnections = 10
	torrent.metadataPeersCh = make(chan peerConnection, 10)
	torrent.peerConnectionPool = newPeerConnectionPool()
	torrent.peers = make(map[string]peer)
	torrent.failingPeers = make(map[string]peer)

	torrent.downloadedPieceCh = make(chan downloadedPiece, 10)
	torrent.failedPiecesCh = make(chan piece, 10)
	torrent.queuedPiecesCh = make(chan piece, 10)

	torrent.trackers = *trackers
	torrent.statusCh = make(chan torrentStatus, 1)

	return &torrent, nil
}

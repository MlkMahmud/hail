package torrent

import (
	"bytes"
	"crypto/sha1"
	"fmt"
	"math"
	"os"
	"path/filepath"
)

type Block struct {
	Begin      int
	Data       []byte
	Length     int
	PieceIndex int
}

type DownloadedPiece struct {
	Data  []byte
	Err   error
	Piece Piece
}

type Piece struct {
	Index  int
	Hash   [sha1.Size]byte
	Length int
}

type piecesParserResult struct {
	nextFileOffset      int
	nextPieceStartIndex int
	pieces              []Piece
}

const (
	BlockSize = 16384
)

func parsePiecesHashes(fileLength int, pieceLength int, pieceOffset int, piecesHashes string) (piecesParserResult, error) {
	result := piecesParserResult{
		nextFileOffset:      0,
		nextPieceStartIndex: 0,
		pieces:              nil,
	}

	availablePiecesLen := len(piecesHashes)
	numOfPieces := int(math.Ceil(float64(fileLength) / float64(pieceLength)))
	piecesArr := make([]Piece, numOfPieces)
	piecesIndex := 0

	if availablePiecesLen%sha1.Size != 0 {
		return result, fmt.Errorf("pieces length must be a multiple of %d", sha1.Size)
	}

	if numOfAvailablePieces := availablePiecesLen / sha1.Size; numOfAvailablePieces < numOfPieces {
		return result, fmt.Errorf("expected pieces hash to contain at least %d pieces, but got %d", numOfPieces, numOfAvailablePieces)
	}

	for i := range numOfPieces {
		pieceHash := []byte(piecesHashes[piecesIndex : sha1.Size+piecesIndex])

		if len(pieceHash) != sha1.Size {
			return result, fmt.Errorf("piece %d has an invalid hash", i)
		}

		piece := Piece{Index: i + pieceOffset, Hash: [sha1.Size]byte(pieceHash)}
		isLastPiece := i == (numOfPieces - 1)

		/*
			All pieces have the same fixed length, except the last piece which may be truncated.
			The truncated length of the last piece can be generated by subtracting the sum of all other pieces from the total length of the file.
		*/
		if isLastPiece {
			piece.Length = fileLength - (pieceLength * (numOfPieces - 1))
		} else {
			piece.Length = pieceLength
		}

		// If it's not a truncated piece advance the pieces hash index and set the start offset for the next file to 0.
		if piece.Length == pieceLength {
			piecesIndex += sha1.Size
			result.nextFileOffset = 0
		} else {
			/*
				In multi-file torrents a single piece can contain data for two files.
				If the last piece of a file is truncated, then that piece includes data
				for the next file too. We need to calculate the offset to know exactly at which
				byte the data for the next file begins.
			*/
			result.nextFileOffset = piece.Length
		}

		piecesArr[i] = piece
	}

	result.nextPieceStartIndex = piecesIndex
	result.pieces = piecesArr

	return result, nil

}

// func parseTorrentPieces(infoDict map[string]any) ([]Piece, error) {
// 	pieceHashes, ok := infoDict["pieces"].(string)

// 	if !ok {
// 		return nil, fmt.Errorf("expected the 'pieces' property of the info dict to be a string, but got %T", pieceHashes)
// 	}

// 	pieceHashesLen := len(pieceHashes)

// 	if pieceHashesLen == 0 {
// 		return nil, fmt.Errorf("the 'pieces' property cannot be an empty string")
// 	}

// 	if pieceHashesLen%sha1.Size != 0 {
// 		return nil, fmt.Errorf("pieces length must be a multiple of %d", sha1.Size)
// 	}

// 	pieceLen, ok := infoDict["piece length"].(int)

// 	if !ok {
// 		return nil, fmt.Errorf("expected the 'piece length' property of the info dict to be an integer, but got %T", pieceLen)
// 	}

// 	fileLen, ok := infoDict["length"].(int)

// 	if !ok {
// 		return nil, fmt.Errorf("expected the 'length' property of the info dict to be an integer, but got %T", fileLen)
// 	}

// 	numOfPieces := pieceHashesLen / sha1.Size
// 	piecesArr := make([]Piece, numOfPieces)

// 	for i, j := 0, 0; i < pieceHashesLen; i += sha1.Size {
// 		pieceHash := []byte(pieceHashes[i : sha1.Size+i])

// 		if len(pieceHash) != sha1.Size {
// 			return nil, fmt.Errorf("piece %d has an invalid hash", j)
// 		}

// 		piece := Piece{Index: j, Hash: [sha1.Size]byte(pieceHash)}

// 		// All pieces have the same fixed length, except the last piece which may be truncated
// 		// The truncated length of the last piece can be generated by subtracting the sum of all other pieces from the total length of the file.
// 		if j == numOfPieces-1 {
// 			piece.Length = fileLen - (pieceLen * (numOfPieces - 1))
// 		} else {
// 			piece.Length = pieceLen
// 		}

// 		piecesArr[j] = piece
// 		j++
// 	}

// 	return piecesArr, nil
// }

func (p *Piece) assembleBlocks(blocks []Block) []byte {
	buffer := make([]byte, p.Length)

	for _, block := range blocks {
		copy(buffer[block.Begin:], block.Data)
	}

	return buffer
}

func (d *DownloadedPiece) CheckHashIntegrity() error {
	downloadedPieceHash := sha1.Sum(d.Data)

	if bytes.Equal(downloadedPieceHash[:], d.Piece.Hash[:]) {
		return nil
	}

	return fmt.Errorf("hash '%x' for downloaded piece at index '%d' does not match expected '%x'", downloadedPieceHash, d.Piece.Index, d.Piece.Hash)
}

func (d *DownloadedPiece) WriteToDisk(dir string) error {
	path := filepath.Join(dir, fmt.Sprintf("%020d.piece", d.Piece.Index))

	if err := os.WriteFile(path, d.Data, 0666); err != nil {
		return fmt.Errorf("failed to write piece '%d' to disk: %w", d.Piece.Index, err)
	}

	return nil
}

func (p *Piece) getBlocks() []Block {
	blocks := []Block{}

	numOfFullSizedBlocks := int(p.Length / BlockSize)

	for i := 0; i < numOfFullSizedBlocks; i++ {
		blocks = append(blocks, Block{Begin: i * BlockSize, Length: BlockSize, PieceIndex: p.Index})
	}

	if lastBlockSize := p.Length % BlockSize; lastBlockSize != 0 {
		lastBlockIndex := numOfFullSizedBlocks * BlockSize
		blocks = append(blocks, Block{Begin: lastBlockIndex, Length: lastBlockSize, PieceIndex: p.Index})
	}

	return blocks
}

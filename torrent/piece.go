package torrent

import (
	"bytes"
	"crypto/sha1"
	"fmt"
	"math"
	"os"
	"path/filepath"
)

type block struct {
	begin      int
	data       []byte
	length     int
	pieceIndex int
}

type downloadedPiece struct {
	data  []byte
	piece piece
}

type piece struct {
	index  int
	hash   [sha1.Size]byte
	length int
}

type piecesParserResult struct {
	nextFileOffset      int
	nextPieceStartIndex int
	pieces              []piece
}

const (
	blockSize = 16384
)

func parsePiecesHashes(fileLength int, pieceLength int, pieceOffset int, piecesHashes string) (piecesParserResult, error) {
	result := piecesParserResult{
		nextFileOffset:      0,
		nextPieceStartIndex: 0,
		pieces:              nil,
	}

	availablePiecesLen := len(piecesHashes)
	numOfPieces := int(math.Ceil(float64(fileLength) / float64(pieceLength)))
	piecesArr := make([]piece, numOfPieces)
	piecesIndex := 0

	if availablePiecesLen%sha1.Size != 0 {
		return result, fmt.Errorf("pieces length must be a multiple of %d", sha1.Size)
	}

	if numOfAvailablePieces := availablePiecesLen / sha1.Size; numOfAvailablePieces < numOfPieces {
		return result, fmt.Errorf("expected pieces hash to contain at least %d pieces, but got %d", numOfPieces, numOfAvailablePieces)
	}

	for i := range numOfPieces {
		pieceHash := []byte(piecesHashes[piecesIndex : sha1.Size+piecesIndex])

		if len(pieceHash) != sha1.Size {
			return result, fmt.Errorf("piece %d has an invalid hash", i)
		}

		piece := piece{index: i + pieceOffset, hash: [sha1.Size]byte(pieceHash)}
		isLastPiece := i == (numOfPieces - 1)

		/*
			All pieces have the same fixed length, except the last piece which may be truncated.
			The truncated length of the last piece can be generated by subtracting the sum of all other pieces from the total length of the file.
		*/
		if isLastPiece {
			piece.length = fileLength - (pieceLength * (numOfPieces - 1))
		} else {
			piece.length = pieceLength
		}

		// If it's not a truncated piece advance the pieces hash index and set the start offset for the next file to 0.
		if piece.length == pieceLength {
			piecesIndex += sha1.Size
			result.nextFileOffset = 0
		} else {
			/*
				In multi-file torrents a single piece can contain data for two files.
				If the last piece of a file is truncated, then that piece includes data
				for the next file too. We need to calculate the offset to know exactly at which
				byte the data for the next file begins.
			*/
			result.nextFileOffset = piece.length
		}

		piecesArr[i] = piece
	}

	result.nextPieceStartIndex = piecesIndex
	result.pieces = piecesArr

	return result, nil

}

func (p *piece) assembleBlocks(blocks []block) []byte {
	buffer := make([]byte, p.length)

	for _, block := range blocks {
		copy(buffer[block.begin:], block.data)
	}

	return buffer
}

func (d *downloadedPiece) validateIntegrity() error {
	downloadedPieceHash := sha1.Sum(d.data)

	if bytes.Equal(downloadedPieceHash[:], d.piece.hash[:]) {
		return nil
	}

	return fmt.Errorf(
		"integrity validation failed for downloaded piece at index '%d':\n"+
			"  - Calculated hash: '%x'\n"+
			"  - Expected hash:   '%x'\n"+
			"  - Piece length:    %d bytes\n"+
			"  - Piece index:     %d",
		d.piece.index,
		downloadedPieceHash,
		d.piece.hash,
		len(d.data),
		d.piece.index,
	)
}

func (d *downloadedPiece) writeToDisk(dir string) error {
	path := filepath.Join(dir, fmt.Sprintf("%020d.piece", d.piece.index))

	if err := os.WriteFile(path, d.data, 0666); err != nil {
		return fmt.Errorf("failed to write piece '%d' to disk: %w", d.piece.index, err)
	}

	return nil
}

func (p *piece) getBlocks() []block {
	blocks := []block{}

	numOfFullSizedBlocks := int(p.length / blockSize)

	for i := range numOfFullSizedBlocks {
		blocks = append(blocks, block{begin: i * blockSize, length: blockSize, pieceIndex: p.index})
	}

	if lastBlockSize := p.length % blockSize; lastBlockSize != 0 {
		lastBlockIndex := numOfFullSizedBlocks * blockSize
		blocks = append(blocks, block{begin: lastBlockIndex, length: lastBlockSize, pieceIndex: p.index})
	}

	return blocks
}
